# Internals
If you're wondering about how Picocrypt handles cryptography, you've come to the right place! This page will contain the technical details about the cryptographic schemes and formats used.

# Core Cryptography
## Encryption
Picocrypt uses these algorithms list of algorithms for encryption:
- XChaCha20 (IETF variant)
- Poly1305
- SHA3
- Argon2id

The first two of them are provided by <a href="https://monocypher.org">Monocypher</a>. Since Monocypher has been audited by Cure53, it's an extremely secure library. To bind Picocrypt (Go) to Monocypher (C), I created a binding called <a href="https://github.com/HACKERALERT/Monocypher-GO">Monocypher-Go</a>, which binds Go to C. For SHA3, Picocrypt uses Go's standard `golang.org/x/crypto/sha3`. For Argon2id, Picocrypt also uses Go's standard `golang.org/x/crypto/argon2`.

### Here's how encryption works:
- An master key is generated by passing the user's password through Argon2id. If fast mode is enabled, Picocrypt uses Argon2id with 4 passes, 128 MiB of memory, and 4 threads. If fast mode is not enabled, Picocrypt uses much more resrouces, with 8 passes, 1 GiB of memory, and 8 threads.
- A SHA3-256 hash of the master key is generated and stored. This is used to let a user know if their password is correct. Note that this is a hash of the <i>derived</i> key, so it doesn't provide any vector for bruteforce.
- Encryption starts in 1 MiB chunks (1048576 bytes). For each chunk, a 24-byte nonce is generated through Go's `crypto/rand`. The nonce is appended into a list. The chunk is encrypted with the master key and unique nonce. The Poly1305 obtained after encrypting is appended to the chunk, which is then written to file.
- When all chunks are encrypted, the list of nonces are encrypted using the master key, and the resulting ciphertext and Poly1305 is written to the output. This is done not to protected the nonces themselves, but to add a layer of Poly1305 on top of the nonces to ensure that they can't be reordered.

# This is a work in progress...
