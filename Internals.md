# Internals
If you're wondering about how Picocrypt handles cryptography, you've come to the right place! This page contains the technical details about the cryptographic algorithms and file format.

# Core Cryptography
## Encryption
Picocrypt uses the following algorithms for encryption:
- XChaCha20-Poly1305 (IETF variant)
- SHA3
- Argon2id

The first is provided by <a href="https://monocypher.org">Monocypher</a>, a library that has been <a href="https://monocypher.org/quality-assurance/audit">audited</a> by Cure53. To bind Picocrypt (written in Go) to Monocypher (written in C), I created a binding called <a href="https://github.com/HACKERALERT/Monocypher-GO">Monocypher-Go</a>. For SHA3, Picocrypt uses Go's built-in `golang.org/x/crypto/sha3`. For Argon2id, Picocrypt also uses Go's built-in `golang.org/x/crypto/argon2`.

### Here's how encryption works:
- A master key is generated by hashing the user's password using Argon2id. If fast mode is enabled, Picocrypt uses Argon2id with 4 passes, 128 MiB of memory, and 4 threads. If fast mode is not enabled, Picocrypt uses 8 passes, 1 GiB of memory, and 8 threads.
- A SHA3-256 hash of the master key is generated and stored. This is used to let the user know if their password is correct. Note that this is a hash of the <i>derived</i> key, so it cannot be bruteforced.
- Encryption occurs in 1 MiB chunks (1048576 bytes). For each chunk, a 24-byte nonce is generated using Go's `crypto/rand`. The nonce is then appended to a list. The chunk is encrypted with the master key and the unique nonce. The Poly1305 tag is obtained after encryption and is appended to the chunk before the chunk is written to file.
- When all the chunks have been encrypted, the list of nonces is encrypted using the master key and written to the file. This is done to prevent the nonces from being reordered.

# This is a work in progress...
